{"ast":null,"code":"import { Program } from '../core/Program.js';\nimport { Mesh } from '../core/Mesh.js';\nimport { RenderTarget } from '../core/RenderTarget.js';\nimport { Triangle } from './Triangle.js';\nexport class Post {\n  constructor(gl, {\n    width,\n    height,\n    dpr,\n    wrapS = gl.CLAMP_TO_EDGE,\n    wrapT = gl.CLAMP_TO_EDGE,\n    minFilter = gl.LINEAR,\n    magFilter = gl.LINEAR,\n    geometry = new Triangle(gl),\n    targetOnly = null,\n    depth = true\n  } = {}) {\n    this.gl = gl;\n    this.passes = [];\n    this.geometry = geometry;\n    this.uniform = {\n      value: null\n    };\n    this.targetOnly = targetOnly;\n    if (dpr) this.dpr = dpr;\n    if (width) this.width = width;\n    if (height) this.height = height;\n    dpr = this.dpr || this.gl.renderer.dpr;\n    this.resolutionWidth = Math.floor(this.width || this.gl.renderer.width * dpr);\n    this.resolutionHeight = Math.floor(this.height || this.gl.renderer.height * dpr);\n    let options = {\n      dpr: this.dpr,\n      width: this.resolutionWidth,\n      height: this.resolutionHeight,\n      wrapS,\n      wrapT,\n      minFilter,\n      magFilter,\n      depth\n    };\n    const fbo = this.fbo = {\n      read: new RenderTarget(this.gl, options),\n      write: new RenderTarget(this.gl, options),\n      swap: () => {\n        let temp = fbo.read;\n        fbo.read = fbo.write;\n        fbo.write = temp;\n      }\n    };\n  }\n  addPass({\n    vertex = defaultVertex,\n    fragment = defaultFragment,\n    uniforms = {},\n    textureUniform = 'tMap',\n    enabled = true\n  } = {}) {\n    uniforms[textureUniform] = {\n      value: this.fbo.read.texture\n    };\n    const program = new Program(this.gl, {\n      vertex,\n      fragment,\n      uniforms\n    });\n    const mesh = new Mesh(this.gl, {\n      geometry: this.geometry,\n      program\n    });\n    const pass = {\n      mesh,\n      program,\n      uniforms,\n      enabled,\n      textureUniform\n    };\n    this.passes.push(pass);\n    return pass;\n  }\n  resize({\n    width,\n    height,\n    dpr\n  } = {}) {\n    if (dpr) this.dpr = dpr;\n    if (width) this.width = width;\n    if (height) this.height = height;\n    dpr = this.dpr || this.gl.renderer.dpr;\n    this.resolutionWidth = Math.floor(this.width || this.gl.renderer.width * dpr);\n    this.resolutionHeight = Math.floor(this.height || this.gl.renderer.height * dpr);\n    this.fbo.read.setSize(this.resolutionWidth, this.resolutionHeight);\n    this.fbo.write.setSize(this.resolutionWidth, this.resolutionHeight);\n  }\n\n  // Uses same arguments as renderer.render, with addition of optional texture passed in to avoid scene render\n  render({\n    scene,\n    camera,\n    texture,\n    target = null,\n    update = true,\n    sort = true,\n    frustumCull = true,\n    beforePostCallbacks\n  }) {\n    const enabledPasses = this.passes.filter(pass => pass.enabled);\n    if (!texture) {\n      this.gl.renderer.render({\n        scene,\n        camera,\n        target: enabledPasses.length || !target && this.targetOnly ? this.fbo.write : target,\n        update,\n        sort,\n        frustumCull\n      });\n      this.fbo.swap();\n\n      // Callback after rendering scene, but before post effects\n      if (beforePostCallbacks) beforePostCallbacks.forEach(f => f && f());\n    }\n    enabledPasses.forEach((pass, i) => {\n      pass.mesh.program.uniforms[pass.textureUniform].value = !i && texture ? texture : this.fbo.read.texture;\n      this.gl.renderer.render({\n        scene: pass.mesh,\n        target: i === enabledPasses.length - 1 && (target || !this.targetOnly) ? target : this.fbo.write,\n        clear: true\n      });\n      this.fbo.swap();\n    });\n    this.uniform.value = this.fbo.read.texture;\n  }\n}\nconst defaultVertex = /* glsl */`\n    attribute vec2 uv;\n    attribute vec2 position;\n\n    varying vec2 vUv;\n\n    void main() {\n        vUv = uv;\n        gl_Position = vec4(position, 0, 1);\n    }\n`;\nconst defaultFragment = /* glsl */`\n    precision highp float;\n\n    uniform sampler2D tMap;\n    varying vec2 vUv;\n\n    void main() {\n        gl_FragColor = texture2D(tMap, vUv);\n    }\n`;","map":{"version":3,"names":["Program","Mesh","RenderTarget","Triangle","Post","constructor","gl","width","height","dpr","wrapS","CLAMP_TO_EDGE","wrapT","minFilter","LINEAR","magFilter","geometry","targetOnly","depth","passes","uniform","value","renderer","resolutionWidth","Math","floor","resolutionHeight","options","fbo","read","write","swap","temp","addPass","vertex","defaultVertex","fragment","defaultFragment","uniforms","textureUniform","enabled","texture","program","mesh","pass","push","resize","setSize","render","scene","camera","target","update","sort","frustumCull","beforePostCallbacks","enabledPasses","filter","length","forEach","f","i","clear"],"sources":["C:/Users/Utilizador/Documents/BASE_WEBSITE/node_modules/ogl/src/extras/Post.js"],"sourcesContent":["import { Program } from '../core/Program.js';\nimport { Mesh } from '../core/Mesh.js';\nimport { RenderTarget } from '../core/RenderTarget.js';\nimport { Triangle } from './Triangle.js';\n\nexport class Post {\n    constructor(\n        gl,\n        {\n            width,\n            height,\n            dpr,\n            wrapS = gl.CLAMP_TO_EDGE,\n            wrapT = gl.CLAMP_TO_EDGE,\n            minFilter = gl.LINEAR,\n            magFilter = gl.LINEAR,\n            geometry = new Triangle(gl),\n            targetOnly = null,\n            depth = true,\n        } = {}\n    ) {\n        this.gl = gl;\n\n        this.passes = [];\n\n        this.geometry = geometry;\n\n        this.uniform = { value: null };\n        this.targetOnly = targetOnly;\n\n        if (dpr) this.dpr = dpr;\n        if (width) this.width = width;\n        if (height) this.height = height;\n\n        dpr = this.dpr || this.gl.renderer.dpr;\n        this.resolutionWidth = Math.floor(this.width || this.gl.renderer.width * dpr);\n        this.resolutionHeight = Math.floor(this.height || this.gl.renderer.height * dpr);\n\n        let options = {\n            dpr: this.dpr,\n            width: this.resolutionWidth,\n            height: this.resolutionHeight,\n            wrapS,\n            wrapT,\n            minFilter,\n            magFilter,\n            depth,\n        };\n\n        const fbo = (this.fbo = {\n            read: new RenderTarget(this.gl, options),\n            write: new RenderTarget(this.gl, options),\n            swap: () => {\n                let temp = fbo.read;\n                fbo.read = fbo.write;\n                fbo.write = temp;\n            },\n        });\n    }\n\n    addPass({ vertex = defaultVertex, fragment = defaultFragment, uniforms = {}, textureUniform = 'tMap', enabled = true } = {}) {\n        uniforms[textureUniform] = { value: this.fbo.read.texture };\n\n        const program = new Program(this.gl, { vertex, fragment, uniforms });\n        const mesh = new Mesh(this.gl, { geometry: this.geometry, program });\n\n        const pass = {\n            mesh,\n            program,\n            uniforms,\n            enabled,\n            textureUniform,\n        };\n\n        this.passes.push(pass);\n        return pass;\n    }\n\n    resize({ width, height, dpr } = {}) {\n        if (dpr) this.dpr = dpr;\n        if (width) this.width = width;\n        if (height) this.height = height;\n\n        dpr = this.dpr || this.gl.renderer.dpr;\n        this.resolutionWidth = Math.floor(this.width || this.gl.renderer.width * dpr);\n        this.resolutionHeight = Math.floor(this.height || this.gl.renderer.height * dpr);\n\n        this.fbo.read.setSize(this.resolutionWidth, this.resolutionHeight);\n        this.fbo.write.setSize(this.resolutionWidth, this.resolutionHeight);\n    }\n\n    // Uses same arguments as renderer.render, with addition of optional texture passed in to avoid scene render\n    render({ scene, camera, texture, target = null, update = true, sort = true, frustumCull = true, beforePostCallbacks }) {\n        const enabledPasses = this.passes.filter((pass) => pass.enabled);\n\n        if (!texture) {\n            this.gl.renderer.render({\n                scene,\n                camera,\n                target: enabledPasses.length || (!target && this.targetOnly) ? this.fbo.write : target,\n                update,\n                sort,\n                frustumCull,\n            });\n            this.fbo.swap();\n\n            // Callback after rendering scene, but before post effects\n            if (beforePostCallbacks) beforePostCallbacks.forEach((f) => f && f());\n        }\n\n        enabledPasses.forEach((pass, i) => {\n            pass.mesh.program.uniforms[pass.textureUniform].value = !i && texture ? texture : this.fbo.read.texture;\n            this.gl.renderer.render({\n                scene: pass.mesh,\n                target: i === enabledPasses.length - 1 && (target || !this.targetOnly) ? target : this.fbo.write,\n                clear: true,\n            });\n            this.fbo.swap();\n        });\n\n        this.uniform.value = this.fbo.read.texture;\n    }\n}\n\nconst defaultVertex = /* glsl */ `\n    attribute vec2 uv;\n    attribute vec2 position;\n\n    varying vec2 vUv;\n\n    void main() {\n        vUv = uv;\n        gl_Position = vec4(position, 0, 1);\n    }\n`;\n\nconst defaultFragment = /* glsl */ `\n    precision highp float;\n\n    uniform sampler2D tMap;\n    varying vec2 vUv;\n\n    void main() {\n        gl_FragColor = texture2D(tMap, vUv);\n    }\n`;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
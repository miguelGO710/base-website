{"ast":null,"code":"import { Vec3 } from '../math/Vec3.js';\nimport { Quat } from '../math/Quat.js';\nconst tmpVec3A = /* @__PURE__ */new Vec3();\nconst tmpVec3B = /* @__PURE__ */new Vec3();\nconst tmpVec3C = /* @__PURE__ */new Vec3();\nconst tmpVec3D = /* @__PURE__ */new Vec3();\nconst tmpQuatA = /* @__PURE__ */new Quat();\nconst tmpQuatB = /* @__PURE__ */new Quat();\nconst tmpQuatC = /* @__PURE__ */new Quat();\nconst tmpQuatD = /* @__PURE__ */new Quat();\nexport class GLTFAnimation {\n  constructor(data, weight = 1) {\n    this.data = data;\n    this.elapsed = 0;\n    this.weight = weight;\n\n    // Set to false to not apply modulo to elapsed against duration\n    this.loop = true;\n\n    // Find starting time as exports from blender (perhaps others too) don't always start from 0\n    this.startTime = data.reduce((a, {\n      times\n    }) => Math.min(a, times[0]), Infinity);\n    // Get largest final time in all channels to calculate duration\n    this.endTime = data.reduce((a, {\n      times\n    }) => Math.max(a, times[times.length - 1]), 0);\n    this.duration = this.endTime - this.startTime;\n  }\n  update(totalWeight = 1, isSet) {\n    const weight = isSet ? 1 : this.weight / totalWeight;\n    const elapsed = !this.duration ? 0 : (this.loop ? this.elapsed % this.duration : Math.min(this.elapsed, this.duration - 0.001)) + this.startTime;\n    this.data.forEach(({\n      node,\n      transform,\n      interpolation,\n      times,\n      values\n    }) => {\n      if (!this.duration) {\n        let val = tmpVec3A;\n        let size = 3;\n        if (transform === 'quaternion') {\n          val = tmpQuatA;\n          size = 4;\n        }\n        val.fromArray(values, 0);\n        if (size === 4) node[transform].slerp(val, weight);else node[transform].lerp(val, weight);\n        return;\n      }\n\n      // Get index of two time values elapsed is between\n      const prevIndex = Math.max(1, times.findIndex(t => t > elapsed)) - 1;\n      const nextIndex = prevIndex + 1;\n\n      // Get linear blend/alpha between the two\n      let alpha = (elapsed - times[prevIndex]) / (times[nextIndex] - times[prevIndex]);\n      if (interpolation === 'STEP') alpha = 0;\n      let prevVal = tmpVec3A;\n      let prevTan = tmpVec3B;\n      let nextTan = tmpVec3C;\n      let nextVal = tmpVec3D;\n      let size = 3;\n      if (transform === 'quaternion') {\n        prevVal = tmpQuatA;\n        prevTan = tmpQuatB;\n        nextTan = tmpQuatC;\n        nextVal = tmpQuatD;\n        size = 4;\n      }\n      if (interpolation === 'CUBICSPLINE') {\n        // Get the prev and next values from the indices\n        prevVal.fromArray(values, prevIndex * size * 3 + size * 1);\n        prevTan.fromArray(values, prevIndex * size * 3 + size * 2);\n        nextTan.fromArray(values, nextIndex * size * 3 + size * 0);\n        nextVal.fromArray(values, nextIndex * size * 3 + size * 1);\n\n        // interpolate for final value\n        prevVal = this.cubicSplineInterpolate(alpha, prevVal, prevTan, nextTan, nextVal);\n        if (size === 4) prevVal.normalize();\n      } else {\n        // Get the prev and next values from the indices\n        prevVal.fromArray(values, prevIndex * size);\n        nextVal.fromArray(values, nextIndex * size);\n\n        // interpolate for final value\n        if (size === 4) prevVal.slerp(nextVal, alpha);else prevVal.lerp(nextVal, alpha);\n      }\n\n      // interpolate between multiple possible animations\n      if (size === 4) node[transform].slerp(prevVal, weight);else node[transform].lerp(prevVal, weight);\n    });\n  }\n  cubicSplineInterpolate(t, prevVal, prevTan, nextTan, nextVal) {\n    const t2 = t * t;\n    const t3 = t2 * t;\n    const s2 = 3 * t2 - 2 * t3;\n    const s3 = t3 - t2;\n    const s0 = 1 - s2;\n    const s1 = s3 - t2 + t;\n    for (let i = 0; i < prevVal.length; i++) {\n      prevVal[i] = s0 * prevVal[i] + s1 * (1 - t) * prevTan[i] + s2 * nextVal[i] + s3 * t * nextTan[i];\n    }\n    return prevVal;\n  }\n}","map":{"version":3,"names":["Vec3","Quat","tmpVec3A","tmpVec3B","tmpVec3C","tmpVec3D","tmpQuatA","tmpQuatB","tmpQuatC","tmpQuatD","GLTFAnimation","constructor","data","weight","elapsed","loop","startTime","reduce","a","times","Math","min","Infinity","endTime","max","length","duration","update","totalWeight","isSet","forEach","node","transform","interpolation","values","val","size","fromArray","slerp","lerp","prevIndex","findIndex","t","nextIndex","alpha","prevVal","prevTan","nextTan","nextVal","cubicSplineInterpolate","normalize","t2","t3","s2","s3","s0","s1","i"],"sources":["C:/Users/Utilizador/Documents/BASE_WEBSITE/node_modules/ogl/src/extras/GLTFAnimation.js"],"sourcesContent":["import { Vec3 } from '../math/Vec3.js';\nimport { Quat } from '../math/Quat.js';\n\nconst tmpVec3A = /* @__PURE__ */ new Vec3();\nconst tmpVec3B = /* @__PURE__ */ new Vec3();\nconst tmpVec3C = /* @__PURE__ */ new Vec3();\nconst tmpVec3D = /* @__PURE__ */ new Vec3();\n\nconst tmpQuatA = /* @__PURE__ */ new Quat();\nconst tmpQuatB = /* @__PURE__ */ new Quat();\nconst tmpQuatC = /* @__PURE__ */ new Quat();\nconst tmpQuatD = /* @__PURE__ */ new Quat();\n\nexport class GLTFAnimation {\n    constructor(data, weight = 1) {\n        this.data = data;\n        this.elapsed = 0;\n        this.weight = weight;\n\n        // Set to false to not apply modulo to elapsed against duration\n        this.loop = true;\n\n        // Find starting time as exports from blender (perhaps others too) don't always start from 0\n        this.startTime = data.reduce((a, { times }) => Math.min(a, times[0]), Infinity);\n        // Get largest final time in all channels to calculate duration\n        this.endTime = data.reduce((a, { times }) => Math.max(a, times[times.length - 1]), 0);\n        this.duration = this.endTime - this.startTime;\n    }\n\n    update(totalWeight = 1, isSet) {\n        const weight = isSet ? 1 : this.weight / totalWeight;\n        const elapsed = !this.duration\n            ? 0\n            : (this.loop ? this.elapsed % this.duration : Math.min(this.elapsed, this.duration - 0.001)) + this.startTime;\n\n        this.data.forEach(({ node, transform, interpolation, times, values }) => {\n            if (!this.duration) {\n                let val = tmpVec3A;\n                let size = 3;\n                if (transform === 'quaternion') {\n                    val = tmpQuatA;\n                    size = 4;\n                }\n                val.fromArray(values, 0);\n                if (size === 4) node[transform].slerp(val, weight);\n                else node[transform].lerp(val, weight);\n                return;\n            }\n\n            // Get index of two time values elapsed is between\n            const prevIndex =\n                Math.max(\n                    1,\n                    times.findIndex((t) => t > elapsed)\n                ) - 1;\n            const nextIndex = prevIndex + 1;\n\n            // Get linear blend/alpha between the two\n            let alpha = (elapsed - times[prevIndex]) / (times[nextIndex] - times[prevIndex]);\n            if (interpolation === 'STEP') alpha = 0;\n\n            let prevVal = tmpVec3A;\n            let prevTan = tmpVec3B;\n            let nextTan = tmpVec3C;\n            let nextVal = tmpVec3D;\n            let size = 3;\n\n            if (transform === 'quaternion') {\n                prevVal = tmpQuatA;\n                prevTan = tmpQuatB;\n                nextTan = tmpQuatC;\n                nextVal = tmpQuatD;\n                size = 4;\n            }\n\n            if (interpolation === 'CUBICSPLINE') {\n                // Get the prev and next values from the indices\n                prevVal.fromArray(values, prevIndex * size * 3 + size * 1);\n                prevTan.fromArray(values, prevIndex * size * 3 + size * 2);\n                nextTan.fromArray(values, nextIndex * size * 3 + size * 0);\n                nextVal.fromArray(values, nextIndex * size * 3 + size * 1);\n\n                // interpolate for final value\n                prevVal = this.cubicSplineInterpolate(alpha, prevVal, prevTan, nextTan, nextVal);\n                if (size === 4) prevVal.normalize();\n            } else {\n                // Get the prev and next values from the indices\n                prevVal.fromArray(values, prevIndex * size);\n                nextVal.fromArray(values, nextIndex * size);\n\n                // interpolate for final value\n                if (size === 4) prevVal.slerp(nextVal, alpha);\n                else prevVal.lerp(nextVal, alpha);\n            }\n\n            // interpolate between multiple possible animations\n            if (size === 4) node[transform].slerp(prevVal, weight);\n            else node[transform].lerp(prevVal, weight);\n        });\n    }\n\n    cubicSplineInterpolate(t, prevVal, prevTan, nextTan, nextVal) {\n        const t2 = t * t;\n        const t3 = t2 * t;\n\n        const s2 = 3 * t2 - 2 * t3;\n        const s3 = t3 - t2;\n        const s0 = 1 - s2;\n        const s1 = s3 - t2 + t;\n\n        for (let i = 0; i < prevVal.length; i++) {\n            prevVal[i] = s0 * prevVal[i] + s1 * (1 - t) * prevTan[i] + s2 * nextVal[i] + s3 * t * nextTan[i];\n        }\n\n        return prevVal;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
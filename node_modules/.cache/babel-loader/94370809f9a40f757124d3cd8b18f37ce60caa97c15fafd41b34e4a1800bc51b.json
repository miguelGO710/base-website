{"ast":null,"code":"// TODO: delete texture\n// TODO: use texSubImage2D for updates (video or when loaded)\n// TODO: need? encoding = linearEncoding\n// TODO: support non-compressed mipmaps uploads\n\nconst emptyPixel = new Uint8Array(4);\nfunction isPowerOf2(value) {\n  return (value & value - 1) === 0;\n}\nlet ID = 1;\nexport class Texture {\n  constructor(gl, {\n    image,\n    target = gl.TEXTURE_2D,\n    type = gl.UNSIGNED_BYTE,\n    format = gl.RGBA,\n    internalFormat = format,\n    wrapS = gl.CLAMP_TO_EDGE,\n    wrapT = gl.CLAMP_TO_EDGE,\n    wrapR = gl.CLAMP_TO_EDGE,\n    generateMipmaps = target === (gl.TEXTURE_2D || gl.TEXTURE_CUBE_MAP),\n    minFilter = generateMipmaps ? gl.NEAREST_MIPMAP_LINEAR : gl.LINEAR,\n    magFilter = gl.LINEAR,\n    premultiplyAlpha = false,\n    unpackAlignment = 4,\n    flipY = target == (gl.TEXTURE_2D || gl.TEXTURE_3D) ? true : false,\n    anisotropy = 0,\n    level = 0,\n    width,\n    // used for RenderTargets or Data Textures\n    height = width,\n    length = 1\n  } = {}) {\n    this.gl = gl;\n    this.id = ID++;\n    this.image = image;\n    this.target = target;\n    this.type = type;\n    this.format = format;\n    this.internalFormat = internalFormat;\n    this.minFilter = minFilter;\n    this.magFilter = magFilter;\n    this.wrapS = wrapS;\n    this.wrapT = wrapT;\n    this.wrapR = wrapR;\n    this.generateMipmaps = generateMipmaps;\n    this.premultiplyAlpha = premultiplyAlpha;\n    this.unpackAlignment = unpackAlignment;\n    this.flipY = flipY;\n    this.anisotropy = Math.min(anisotropy, this.gl.renderer.parameters.maxAnisotropy);\n    this.level = level;\n    this.width = width;\n    this.height = height;\n    this.length = length;\n    this.texture = this.gl.createTexture();\n    this.store = {\n      image: null\n    };\n\n    // Alias for state store to avoid redundant calls for global state\n    this.glState = this.gl.renderer.state;\n\n    // State store to avoid redundant calls for per-texture state\n    this.state = {};\n    this.state.minFilter = this.gl.NEAREST_MIPMAP_LINEAR;\n    this.state.magFilter = this.gl.LINEAR;\n    this.state.wrapS = this.gl.REPEAT;\n    this.state.wrapT = this.gl.REPEAT;\n    this.state.anisotropy = 0;\n  }\n  bind() {\n    // Already bound to active texture unit\n    if (this.glState.textureUnits[this.glState.activeTextureUnit] === this.id) return;\n    this.gl.bindTexture(this.target, this.texture);\n    this.glState.textureUnits[this.glState.activeTextureUnit] = this.id;\n  }\n  update(textureUnit = 0) {\n    const needsUpdate = !(this.image === this.store.image && !this.needsUpdate);\n\n    // Make sure that texture is bound to its texture unit\n    if (needsUpdate || this.glState.textureUnits[textureUnit] !== this.id) {\n      // set active texture unit to perform texture functions\n      this.gl.renderer.activeTexture(textureUnit);\n      this.bind();\n    }\n    if (!needsUpdate) return;\n    this.needsUpdate = false;\n    if (this.flipY !== this.glState.flipY) {\n      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, this.flipY);\n      this.glState.flipY = this.flipY;\n    }\n    if (this.premultiplyAlpha !== this.glState.premultiplyAlpha) {\n      this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);\n      this.glState.premultiplyAlpha = this.premultiplyAlpha;\n    }\n    if (this.unpackAlignment !== this.glState.unpackAlignment) {\n      this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, this.unpackAlignment);\n      this.glState.unpackAlignment = this.unpackAlignment;\n    }\n    if (this.minFilter !== this.state.minFilter) {\n      this.gl.texParameteri(this.target, this.gl.TEXTURE_MIN_FILTER, this.minFilter);\n      this.state.minFilter = this.minFilter;\n    }\n    if (this.magFilter !== this.state.magFilter) {\n      this.gl.texParameteri(this.target, this.gl.TEXTURE_MAG_FILTER, this.magFilter);\n      this.state.magFilter = this.magFilter;\n    }\n    if (this.wrapS !== this.state.wrapS) {\n      this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.wrapS);\n      this.state.wrapS = this.wrapS;\n    }\n    if (this.wrapT !== this.state.wrapT) {\n      this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.wrapT);\n      this.state.wrapT = this.wrapT;\n    }\n    if (this.wrapR !== this.state.wrapR) {\n      this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_R, this.wrapR);\n      this.state.wrapR = this.wrapR;\n    }\n    if (this.anisotropy && this.anisotropy !== this.state.anisotropy) {\n      this.gl.texParameterf(this.target, this.gl.renderer.getExtension('EXT_texture_filter_anisotropic').TEXTURE_MAX_ANISOTROPY_EXT, this.anisotropy);\n      this.state.anisotropy = this.anisotropy;\n    }\n    if (this.image) {\n      if (this.image.width) {\n        this.width = this.image.width;\n        this.height = this.image.height;\n      }\n      if (this.target === this.gl.TEXTURE_CUBE_MAP) {\n        // For cube maps\n        for (let i = 0; i < 6; i++) {\n          this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, this.level, this.internalFormat, this.format, this.type, this.image[i]);\n        }\n      } else if (ArrayBuffer.isView(this.image)) {\n        // Data texture\n        if (this.target === this.gl.TEXTURE_2D) {\n          this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, this.image);\n        } else if (this.target === this.gl.TEXTURE_2D_ARRAY || this.target === this.gl.TEXTURE_3D) {\n          this.gl.texImage3D(this.target, this.level, this.internalFormat, this.width, this.height, this.length, 0, this.format, this.type, this.image);\n        }\n      } else if (this.image.isCompressedTexture) {\n        // Compressed texture\n        for (let level = 0; level < this.image.length; level++) {\n          this.gl.compressedTexImage2D(this.target, level, this.internalFormat, this.image[level].width, this.image[level].height, 0, this.image[level].data);\n        }\n      } else {\n        // Regular texture\n        if (this.target === this.gl.TEXTURE_2D) {\n          this.gl.texImage2D(this.target, this.level, this.internalFormat, this.format, this.type, this.image);\n        } else {\n          this.gl.texImage3D(this.target, this.level, this.internalFormat, this.width, this.height, this.length, 0, this.format, this.type, this.image);\n        }\n      }\n      if (this.generateMipmaps) {\n        // For WebGL1, if not a power of 2, turn off mips, set wrapping to clamp to edge and minFilter to linear\n        if (!this.gl.renderer.isWebgl2 && (!isPowerOf2(this.image.width) || !isPowerOf2(this.image.height))) {\n          this.generateMipmaps = false;\n          this.wrapS = this.wrapT = this.gl.CLAMP_TO_EDGE;\n          this.minFilter = this.gl.LINEAR;\n        } else {\n          this.gl.generateMipmap(this.target);\n        }\n      }\n\n      // Callback for when data is pushed to GPU\n      this.onUpdate && this.onUpdate();\n    } else {\n      if (this.target === this.gl.TEXTURE_CUBE_MAP) {\n        // Upload empty pixel for each side while no image to avoid errors while image or video loading\n        for (let i = 0; i < 6; i++) {\n          this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, emptyPixel);\n        }\n      } else if (this.width) {\n        // image intentionally left null for RenderTarget\n        if (this.target === this.gl.TEXTURE_2D) {\n          this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, null);\n        } else {\n          this.gl.texImage3D(this.target, this.level, this.internalFormat, this.width, this.height, this.length, 0, this.format, this.type, null);\n        }\n      } else {\n        // Upload empty pixel if no image to avoid errors while image or video loading\n        this.gl.texImage2D(this.target, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, emptyPixel);\n      }\n    }\n    this.store.image = this.image;\n  }\n}","map":{"version":3,"names":["emptyPixel","Uint8Array","isPowerOf2","value","ID","Texture","constructor","gl","image","target","TEXTURE_2D","type","UNSIGNED_BYTE","format","RGBA","internalFormat","wrapS","CLAMP_TO_EDGE","wrapT","wrapR","generateMipmaps","TEXTURE_CUBE_MAP","minFilter","NEAREST_MIPMAP_LINEAR","LINEAR","magFilter","premultiplyAlpha","unpackAlignment","flipY","TEXTURE_3D","anisotropy","level","width","height","length","id","Math","min","renderer","parameters","maxAnisotropy","texture","createTexture","store","glState","state","REPEAT","bind","textureUnits","activeTextureUnit","bindTexture","update","textureUnit","needsUpdate","activeTexture","pixelStorei","UNPACK_FLIP_Y_WEBGL","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_ALIGNMENT","texParameteri","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","TEXTURE_WRAP_T","TEXTURE_WRAP_R","texParameterf","getExtension","TEXTURE_MAX_ANISOTROPY_EXT","i","texImage2D","TEXTURE_CUBE_MAP_POSITIVE_X","ArrayBuffer","isView","TEXTURE_2D_ARRAY","texImage3D","isCompressedTexture","compressedTexImage2D","data","isWebgl2","generateMipmap","onUpdate"],"sources":["C:/Users/Utilizador/Documents/BASE_WEBSITE/node_modules/ogl/src/core/Texture.js"],"sourcesContent":["// TODO: delete texture\n// TODO: use texSubImage2D for updates (video or when loaded)\n// TODO: need? encoding = linearEncoding\n// TODO: support non-compressed mipmaps uploads\n\nconst emptyPixel = new Uint8Array(4);\n\nfunction isPowerOf2(value) {\n    return (value & (value - 1)) === 0;\n}\n\nlet ID = 1;\n\nexport class Texture {\n    constructor(\n        gl,\n        {\n            image,\n            target = gl.TEXTURE_2D,\n            type = gl.UNSIGNED_BYTE,\n            format = gl.RGBA,\n            internalFormat = format,\n            wrapS = gl.CLAMP_TO_EDGE,\n            wrapT = gl.CLAMP_TO_EDGE,\n            wrapR = gl.CLAMP_TO_EDGE,\n            generateMipmaps = target === (gl.TEXTURE_2D || gl.TEXTURE_CUBE_MAP),\n            minFilter = generateMipmaps ? gl.NEAREST_MIPMAP_LINEAR : gl.LINEAR,\n            magFilter = gl.LINEAR,\n            premultiplyAlpha = false,\n            unpackAlignment = 4,\n            flipY = target == (gl.TEXTURE_2D || gl.TEXTURE_3D) ? true : false,\n            anisotropy = 0,\n            level = 0,\n            width, // used for RenderTargets or Data Textures\n            height = width,\n            length = 1,\n        } = {}\n    ) {\n        this.gl = gl;\n        this.id = ID++;\n\n        this.image = image;\n        this.target = target;\n        this.type = type;\n        this.format = format;\n        this.internalFormat = internalFormat;\n        this.minFilter = minFilter;\n        this.magFilter = magFilter;\n        this.wrapS = wrapS;\n        this.wrapT = wrapT;\n        this.wrapR = wrapR;\n        this.generateMipmaps = generateMipmaps;\n        this.premultiplyAlpha = premultiplyAlpha;\n        this.unpackAlignment = unpackAlignment;\n        this.flipY = flipY;\n        this.anisotropy = Math.min(anisotropy, this.gl.renderer.parameters.maxAnisotropy);\n        this.level = level;\n        this.width = width;\n        this.height = height;\n        this.length = length;\n        this.texture = this.gl.createTexture();\n\n        this.store = {\n            image: null,\n        };\n\n        // Alias for state store to avoid redundant calls for global state\n        this.glState = this.gl.renderer.state;\n\n        // State store to avoid redundant calls for per-texture state\n        this.state = {};\n        this.state.minFilter = this.gl.NEAREST_MIPMAP_LINEAR;\n        this.state.magFilter = this.gl.LINEAR;\n        this.state.wrapS = this.gl.REPEAT;\n        this.state.wrapT = this.gl.REPEAT;\n        this.state.anisotropy = 0;\n    }\n\n    bind() {\n        // Already bound to active texture unit\n        if (this.glState.textureUnits[this.glState.activeTextureUnit] === this.id) return;\n        this.gl.bindTexture(this.target, this.texture);\n        this.glState.textureUnits[this.glState.activeTextureUnit] = this.id;\n    }\n\n    update(textureUnit = 0) {\n        const needsUpdate = !(this.image === this.store.image && !this.needsUpdate);\n\n        // Make sure that texture is bound to its texture unit\n        if (needsUpdate || this.glState.textureUnits[textureUnit] !== this.id) {\n            // set active texture unit to perform texture functions\n            this.gl.renderer.activeTexture(textureUnit);\n            this.bind();\n        }\n\n        if (!needsUpdate) return;\n        this.needsUpdate = false;\n\n        if (this.flipY !== this.glState.flipY) {\n            this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, this.flipY);\n            this.glState.flipY = this.flipY;\n        }\n\n        if (this.premultiplyAlpha !== this.glState.premultiplyAlpha) {\n            this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);\n            this.glState.premultiplyAlpha = this.premultiplyAlpha;\n        }\n\n        if (this.unpackAlignment !== this.glState.unpackAlignment) {\n            this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, this.unpackAlignment);\n            this.glState.unpackAlignment = this.unpackAlignment;\n        }\n\n        if (this.minFilter !== this.state.minFilter) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_MIN_FILTER, this.minFilter);\n            this.state.minFilter = this.minFilter;\n        }\n\n        if (this.magFilter !== this.state.magFilter) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_MAG_FILTER, this.magFilter);\n            this.state.magFilter = this.magFilter;\n        }\n\n        if (this.wrapS !== this.state.wrapS) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.wrapS);\n            this.state.wrapS = this.wrapS;\n        }\n\n        if (this.wrapT !== this.state.wrapT) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.wrapT);\n            this.state.wrapT = this.wrapT;\n        }\n\n        if (this.wrapR !== this.state.wrapR) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_R, this.wrapR);\n            this.state.wrapR = this.wrapR;\n        }\n\n        if (this.anisotropy && this.anisotropy !== this.state.anisotropy) {\n            this.gl.texParameterf(this.target, this.gl.renderer.getExtension('EXT_texture_filter_anisotropic').TEXTURE_MAX_ANISOTROPY_EXT, this.anisotropy);\n            this.state.anisotropy = this.anisotropy;\n        }\n\n        if (this.image) {\n            if (this.image.width) {\n                this.width = this.image.width;\n                this.height = this.image.height;\n            }\n\n            if (this.target === this.gl.TEXTURE_CUBE_MAP) {\n                // For cube maps\n                for (let i = 0; i < 6; i++) {\n                    this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, this.level, this.internalFormat, this.format, this.type, this.image[i]);\n                }\n            } else if (ArrayBuffer.isView(this.image)) {\n                // Data texture\n                if (this.target === this.gl.TEXTURE_2D) {\n                    this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, this.image);\n                } else if (this.target === this.gl.TEXTURE_2D_ARRAY || this.target === this.gl.TEXTURE_3D) {\n                    this.gl.texImage3D(this.target, this.level, this.internalFormat, this.width, this.height, this.length, 0, this.format, this.type, this.image);\n                }\n            } else if (this.image.isCompressedTexture) {\n                // Compressed texture\n                for (let level = 0; level < this.image.length; level++) {\n                    this.gl.compressedTexImage2D(this.target, level, this.internalFormat, this.image[level].width, this.image[level].height, 0, this.image[level].data);\n                }\n            } else {\n                // Regular texture\n                if (this.target === this.gl.TEXTURE_2D) {\n                    this.gl.texImage2D(this.target, this.level, this.internalFormat, this.format, this.type, this.image);\n                } else {\n                    this.gl.texImage3D(this.target, this.level, this.internalFormat, this.width, this.height, this.length, 0, this.format, this.type, this.image);\n                }\n            }\n\n            if (this.generateMipmaps) {\n                // For WebGL1, if not a power of 2, turn off mips, set wrapping to clamp to edge and minFilter to linear\n                if (!this.gl.renderer.isWebgl2 && (!isPowerOf2(this.image.width) || !isPowerOf2(this.image.height))) {\n                    this.generateMipmaps = false;\n                    this.wrapS = this.wrapT = this.gl.CLAMP_TO_EDGE;\n                    this.minFilter = this.gl.LINEAR;\n                } else {\n                    this.gl.generateMipmap(this.target);\n                }\n            }\n\n            // Callback for when data is pushed to GPU\n            this.onUpdate && this.onUpdate();\n        } else {\n            if (this.target === this.gl.TEXTURE_CUBE_MAP) {\n                // Upload empty pixel for each side while no image to avoid errors while image or video loading\n                for (let i = 0; i < 6; i++) {\n                    this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, emptyPixel);\n                }\n            } else if (this.width) {\n                // image intentionally left null for RenderTarget\n                if (this.target === this.gl.TEXTURE_2D) {\n                    this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, null);\n                } else {\n                    this.gl.texImage3D(this.target, this.level, this.internalFormat, this.width, this.height, this.length, 0, this.format, this.type, null);\n                }\n            } else {\n                // Upload empty pixel if no image to avoid errors while image or video loading\n                this.gl.texImage2D(this.target, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, emptyPixel);\n            }\n        }\n        this.store.image = this.image;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { Camera } from '../core/Camera.js';\nimport { Program } from '../core/Program.js';\nimport { RenderTarget } from '../core/RenderTarget.js';\nexport class Shadow {\n  constructor(gl, {\n    light = new Camera(gl),\n    width = 1024,\n    height = width\n  }) {\n    this.gl = gl;\n    this.light = light;\n    this.target = new RenderTarget(gl, {\n      width,\n      height\n    });\n    this.targetUniform = {\n      value: this.target.texture\n    };\n    this.depthProgram = new Program(gl, {\n      vertex: defaultVertex,\n      fragment: defaultFragment,\n      cullFace: false\n    });\n    this.castMeshes = [];\n  }\n  add({\n    mesh,\n    receive = true,\n    cast = true,\n    vertex = defaultVertex,\n    fragment = defaultFragment,\n    uniformProjection = 'shadowProjectionMatrix',\n    uniformView = 'shadowViewMatrix',\n    uniformTexture = 'tShadow'\n  }) {\n    // Add uniforms to existing program\n    if (receive && !mesh.program.uniforms[uniformProjection]) {\n      mesh.program.uniforms[uniformProjection] = {\n        value: this.light.projectionMatrix\n      };\n      mesh.program.uniforms[uniformView] = {\n        value: this.light.viewMatrix\n      };\n      mesh.program.uniforms[uniformTexture] = this.targetUniform;\n    }\n    if (!cast) return;\n    this.castMeshes.push(mesh);\n\n    // Store program for when switching between depth override\n    mesh.colorProgram = mesh.program;\n\n    // Check if depth program already attached\n    if (mesh.depthProgram) return;\n\n    // Use global depth override if nothing custom passed in\n    if (vertex === defaultVertex && fragment === defaultFragment) {\n      mesh.depthProgram = this.depthProgram;\n      return;\n    }\n\n    // Create custom override program\n    mesh.depthProgram = new Program(this.gl, {\n      vertex,\n      fragment,\n      cullFace: false\n    });\n  }\n  setSize({\n    width = 1024,\n    height = width\n  }) {\n    this.target = new RenderTarget(this.gl, {\n      width,\n      height\n    });\n    this.targetUniform.value = this.target.texture;\n  }\n  render({\n    scene\n  }) {\n    // For depth render, replace program with depth override.\n    // Hide meshes not casting shadows.\n    scene.traverse(node => {\n      if (!node.draw) return;\n      if (!!~this.castMeshes.indexOf(node)) {\n        node.program = node.depthProgram;\n      } else {\n        node.isForceVisibility = node.visible;\n        node.visible = false;\n      }\n    });\n\n    // Render the depth shadow map using the light as the camera\n    this.gl.renderer.render({\n      scene,\n      camera: this.light,\n      target: this.target\n    });\n\n    // Then switch the program back to the normal one\n    scene.traverse(node => {\n      if (!node.draw) return;\n      if (!!~this.castMeshes.indexOf(node)) {\n        node.program = node.colorProgram;\n      } else {\n        node.visible = node.isForceVisibility;\n      }\n    });\n  }\n}\nconst defaultVertex = /* glsl */`\n    attribute vec3 position;\n    attribute vec2 uv;\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    void main() {\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n`;\nconst defaultFragment = /* glsl */`\n    precision highp float;\n\n    vec4 packRGBA (float v) {\n        vec4 pack = fract(vec4(1.0, 255.0, 65025.0, 16581375.0) * v);\n        pack -= pack.yzww * vec2(1.0 / 255.0, 0.0).xxxy;\n        return pack;\n    }\n\n    void main() {\n        gl_FragColor = packRGBA(gl_FragCoord.z);\n    }\n`;","map":{"version":3,"names":["Camera","Program","RenderTarget","Shadow","constructor","gl","light","width","height","target","targetUniform","value","texture","depthProgram","vertex","defaultVertex","fragment","defaultFragment","cullFace","castMeshes","add","mesh","receive","cast","uniformProjection","uniformView","uniformTexture","program","uniforms","projectionMatrix","viewMatrix","push","colorProgram","setSize","render","scene","traverse","node","draw","indexOf","isForceVisibility","visible","renderer","camera"],"sources":["C:/Users/Utilizador/Documents/BASE_WEBSITE/node_modules/ogl/src/extras/Shadow.js"],"sourcesContent":["import { Camera } from '../core/Camera.js';\nimport { Program } from '../core/Program.js';\nimport { RenderTarget } from '../core/RenderTarget.js';\n\nexport class Shadow {\n    constructor(gl, { light = new Camera(gl), width = 1024, height = width }) {\n        this.gl = gl;\n\n        this.light = light;\n\n        this.target = new RenderTarget(gl, { width, height });\n        this.targetUniform = { value: this.target.texture };\n\n        this.depthProgram = new Program(gl, {\n            vertex: defaultVertex,\n            fragment: defaultFragment,\n            cullFace: false,\n        });\n\n        this.castMeshes = [];\n    }\n\n    add({\n        mesh,\n        receive = true,\n        cast = true,\n        vertex = defaultVertex,\n        fragment = defaultFragment,\n        uniformProjection = 'shadowProjectionMatrix',\n        uniformView = 'shadowViewMatrix',\n        uniformTexture = 'tShadow',\n    }) {\n        // Add uniforms to existing program\n        if (receive && !mesh.program.uniforms[uniformProjection]) {\n            mesh.program.uniforms[uniformProjection] = { value: this.light.projectionMatrix };\n            mesh.program.uniforms[uniformView] = { value: this.light.viewMatrix };\n            mesh.program.uniforms[uniformTexture] = this.targetUniform;\n        }\n\n        if (!cast) return;\n        this.castMeshes.push(mesh);\n\n        // Store program for when switching between depth override\n        mesh.colorProgram = mesh.program;\n\n        // Check if depth program already attached\n        if (mesh.depthProgram) return;\n\n        // Use global depth override if nothing custom passed in\n        if (vertex === defaultVertex && fragment === defaultFragment) {\n            mesh.depthProgram = this.depthProgram;\n            return;\n        }\n\n        // Create custom override program\n        mesh.depthProgram = new Program(this.gl, {\n            vertex,\n            fragment,\n            cullFace: false,\n        });\n    }\n\n    setSize({ width = 1024, height = width }) {\n        this.target = new RenderTarget(this.gl, { width, height });\n        this.targetUniform.value = this.target.texture;\n    }\n\n    render({ scene }) {\n        // For depth render, replace program with depth override.\n        // Hide meshes not casting shadows.\n        scene.traverse((node) => {\n            if (!node.draw) return;\n            if (!!~this.castMeshes.indexOf(node)) {\n                node.program = node.depthProgram;\n            } else {\n                node.isForceVisibility = node.visible;\n                node.visible = false;\n            }\n        });\n\n        // Render the depth shadow map using the light as the camera\n        this.gl.renderer.render({\n            scene,\n            camera: this.light,\n            target: this.target,\n        });\n\n        // Then switch the program back to the normal one\n        scene.traverse((node) => {\n            if (!node.draw) return;\n            if (!!~this.castMeshes.indexOf(node)) {\n                node.program = node.colorProgram;\n            } else {\n                node.visible = node.isForceVisibility;\n            }\n        });\n    }\n}\n\nconst defaultVertex = /* glsl */ `\n    attribute vec3 position;\n    attribute vec2 uv;\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    void main() {\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n`;\n\nconst defaultFragment = /* glsl */ `\n    precision highp float;\n\n    vec4 packRGBA (float v) {\n        vec4 pack = fract(vec4(1.0, 255.0, 65025.0, 16581375.0) * v);\n        pack -= pack.yzww * vec2(1.0 / 255.0, 0.0).xxxy;\n        return pack;\n    }\n\n    void main() {\n        gl_FragColor = packRGBA(gl_FragCoord.z);\n    }\n`;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
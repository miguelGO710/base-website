{"ast":null,"code":"import { Vec3 } from '../../math/Vec3.js';\nimport { Mat4 } from '../../math/Mat4.js';\nimport CubicBezierSegment from './CubicBezierSegment.js';\nimport QuadraticBezierSegment from './QuadraticBezierSegment.js';\nimport LineSegment from './LineSegment.js';\nimport { clamp, toDegrees, toRadian, mat4fromRotationSinCos, rotateNormalBinormal } from './utils.js';\nconst tempVec3 = /* @__PURE__ */new Vec3();\nconst tempMat4 = /* @__PURE__ */new Mat4();\nfunction throwIfNullProperty(property, message) {\n  if (this[property] == null) throw new Error(message);\n}\nexport class Path {\n  constructor() {\n    this._segments = [];\n    this._lengthOffsets = null;\n    this._totalLength = -1;\n    this._lastPoint = null;\n    this._lastTilt = 0;\n    this._assertLastPoint = throwIfNullProperty.bind(this, '_lastPoint', 'Can`t get previous point of curve. Did you forget moveTo command?');\n    this.tiltFunction = null;\n  }\n  moveTo(p, tilt = 0) {\n    this._totalLength = -1;\n    this._lastPoint = p;\n    this._lastTilt = tilt;\n  }\n  bezierCurveTo(cp1, cp2, p, tilt = 0) {\n    this._assertLastPoint();\n    const seg = new CubicBezierSegment(this._lastPoint, cp1, cp2, p, this._lastTilt, tilt);\n    this.addSegment(seg);\n    return this;\n  }\n  quadraticCurveTo(cp, p, tilt = 0) {\n    this._assertLastPoint();\n    const seg = new QuadraticBezierSegment(this._lastPoint, cp, p, this._lastTilt, tilt);\n    this.addSegment(seg);\n    return this;\n  }\n  lineTo(p, tilt = 0) {\n    this._assertLastPoint();\n    const seg = new LineSegment(this._lastPoint, p, this._lastTilt, tilt);\n    this.addSegment(seg);\n    return this;\n  }\n  addSegment(segment) {\n    this._totalLength = -1;\n    this._lastPoint = segment.lastPoint();\n    this._lastTilt = segment.tiltEnd;\n    this._segments.push(segment);\n    return this;\n  }\n  getSegments() {\n    return this._segments;\n  }\n  updateLength() {\n    const n = this._segments.length;\n    this._lengthOffsets = new Array(n);\n    let offset = 0;\n    for (let i = 0; i < n; i++) {\n      this._lengthOffsets[i] = offset;\n      offset += this._segments[i].getLength();\n    }\n    this._totalLength = offset;\n  }\n  getLength() {\n    if (this._totalLength < 0) {\n      this.updateLength();\n    }\n    return this._totalLength;\n  }\n\n  /**\n   * Finding a path segment at a given absolute length distance\n   * @param {number} len absolute length distance\n   * @returns {[number, number]} [_segment index_, _relative segment distance_]\n   */\n  findSegmentIndexAtLength(len) {\n    const totalLength = this.getLength();\n    if (len <= 0) {\n      return [0, 0];\n    }\n    if (len >= totalLength) {\n      return [this._segments.length - 1, 1];\n    }\n    let start = 0;\n    let end = this._lengthOffsets.length - 1;\n    let index = -1;\n    let mid;\n    while (start <= end) {\n      mid = Math.ceil((start + end) / 2);\n      if (mid === 0 || mid === this._lengthOffsets.length - 1 || len >= this._lengthOffsets[mid] && len < this._lengthOffsets[mid + 1]) {\n        index = mid;\n        break;\n      } else if (len < this._lengthOffsets[mid]) {\n        end = mid - 1;\n      } else {\n        start = mid + 1;\n      }\n    }\n    const seg = this._segments[index];\n    const segLen = seg.getLength();\n    const t = (len - this._lengthOffsets[index]) / segLen;\n    return [index, t];\n  }\n  getPointAtLength(len, out = new Vec3()) {\n    const [i, t] = this.findSegmentIndexAtLength(len);\n    return this._segments[i].getPointAt(t, out);\n  }\n  getPointAt(t, out = new Vec3()) {\n    const totalLength = this.getLength();\n    return this.getPointAtLength(t * totalLength, out);\n  }\n  getTangentAtLength(len, out = new Vec3()) {\n    const [i, t] = this.findSegmentIndexAtLength(len);\n    return this._segments[i].getTangentAt(t, out);\n  }\n  getTangentAt(t, out = new Vec3()) {\n    const totalLength = this.getLength();\n    return this.getTangentAtLength(t * totalLength, out);\n  }\n  getTiltAtLength(len) {\n    const [i, t] = this.findSegmentIndexAtLength(len);\n    return this._segments[i].getTiltAt(t);\n  }\n  getTiltAt(t) {\n    const totalLength = this.getLength();\n    return this.getTiltAtLength(t * totalLength);\n  }\n\n  /**\n   * Get sequence of points using `getPointAt(t)`\n   * @param {number} divisions number of subdivisions\n   * @returns {Vec3[]} array of points\n   */\n  getPoints(divisions = 64) {\n    const points = new Array(divisions + 1);\n    for (let i = 0; i <= divisions; i++) {\n      points[i] = this.getPointAt(i / divisions);\n    }\n    return points;\n  }\n\n  /**\n   * Generates the Frenet Frames.\n   * See http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n   * @param {number} divisions number of subdivisions\n   * @returns {{tangents: Vec3[], normals: Vec3[], binormals: Vec3[]}} Object with tangents, normals and binormals arrays\n   */\n  computeFrenetFrames(divisions = 64, closed = false) {\n    const tangents = new Array(divisions + 1);\n    const tilts = new Array(divisions + 1);\n    const tiltFunction = this.tiltFunction ?? (a => a);\n\n    // compute the tangent vectors and tilt for each segment on the curve\n    const totalLength = this.getLength();\n    for (let i = 0; i <= divisions; i++) {\n      const [si, st] = this.findSegmentIndexAtLength(totalLength * i / divisions);\n      const segment = this._segments[si];\n      tangents[i] = segment.getTangentAt(st);\n      tilts[i] = tiltFunction(segment.getTiltAt(st), i / divisions, this);\n    }\n    const tx = Math.abs(tangents[0].x);\n    const ty = Math.abs(tangents[0].y);\n    const tz = Math.abs(tangents[0].z);\n    const normal = new Vec3();\n    if (tx < ty && tx < tz) {\n      normal.set(1, 0, 0);\n    } else if (ty < tx && ty < tz) {\n      normal.set(0, 1, 0);\n    } else {\n      normal.set(0, 0, 1);\n    }\n\n    // select an initial normal vector perpendicular to the first tangent vector,\n    // and in the direction of the minimum tangent xyz component\n    const normals = new Array(divisions + 1);\n    const binormals = new Array(divisions + 1);\n    normals[0] = new Vec3();\n    binormals[0] = new Vec3();\n    tempVec3.cross(tangents[0], normal).normalize();\n    normals[0].cross(tangents[0], tempVec3);\n    binormals[0].cross(tangents[0], normals[0]);\n\n    // compute the slowly-varying normal vector for each segment on the curve\n    for (let i = 1; i < tangents.length; i++) {\n      normals[i] = normals[i - 1].clone();\n      binormals[i] = new Vec3();\n      tempVec3.cross(tangents[i - 1], tangents[i]);\n      const crossLen = tempVec3.len();\n      if (crossLen > Number.EPSILON) {\n        tempVec3.scale(1 / crossLen); // nomalize\n        const cosTheta = clamp(tangents[i - 1].dot(tangents[i]), -1, 1); // clamp for floating pt errors\n        const sinTheta = clamp(crossLen, -1, 1);\n        mat4fromRotationSinCos(tempMat4, tempVec3, sinTheta, cosTheta);\n        normals[i].applyMatrix4(tempMat4);\n      }\n      binormals[i].cross(tangents[i], normals[i]);\n    }\n\n    // add tilt twisting\n    for (let i = 0; i < tilts.length; i++) {\n      rotateNormalBinormal(toRadian(tilts[i]), normals[i], binormals[i]);\n    }\n\n    // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n    if (closed === true) {\n      const normalLast = normals[normals.length - 1];\n      let step = Math.acos(clamp(normals[0].dot(normalLast), -1, 1)) / (normals.length - 1);\n      if (tangents[0].dot(tempVec3.cross(normals[0], normalLast)) > 0) {\n        step = -step;\n      }\n      for (let i = 1; i < normals.length - 1; i++) {\n        const angle = step * i;\n        rotateNormalBinormal(angle, normals[i], binormals[i]);\n        tilts[i] += toDegrees(angle);\n      }\n      normals[normals.length - 1] = normals[0].clone();\n      binormals[binormals.length - 1] = binormals[0].clone();\n    }\n    return {\n      tangents,\n      normals,\n      binormals,\n      tilts\n    };\n  }\n}","map":{"version":3,"names":["Vec3","Mat4","CubicBezierSegment","QuadraticBezierSegment","LineSegment","clamp","toDegrees","toRadian","mat4fromRotationSinCos","rotateNormalBinormal","tempVec3","tempMat4","throwIfNullProperty","property","message","Error","Path","constructor","_segments","_lengthOffsets","_totalLength","_lastPoint","_lastTilt","_assertLastPoint","bind","tiltFunction","moveTo","p","tilt","bezierCurveTo","cp1","cp2","seg","addSegment","quadraticCurveTo","cp","lineTo","segment","lastPoint","tiltEnd","push","getSegments","updateLength","n","length","Array","offset","i","getLength","findSegmentIndexAtLength","len","totalLength","start","end","index","mid","Math","ceil","segLen","t","getPointAtLength","out","getPointAt","getTangentAtLength","getTangentAt","getTiltAtLength","getTiltAt","getPoints","divisions","points","computeFrenetFrames","closed","tangents","tilts","a","si","st","tx","abs","x","ty","y","tz","z","normal","set","normals","binormals","cross","normalize","clone","crossLen","Number","EPSILON","scale","cosTheta","dot","sinTheta","applyMatrix4","normalLast","step","acos","angle"],"sources":["C:/Users/Utilizador/Documents/BASE_WEBSITE/node_modules/ogl/src/extras/path/Path.js"],"sourcesContent":["import { Vec3 } from '../../math/Vec3.js';\nimport { Mat4 } from '../../math/Mat4.js';\nimport CubicBezierSegment from './CubicBezierSegment.js';\nimport QuadraticBezierSegment from './QuadraticBezierSegment.js';\nimport LineSegment from './LineSegment.js';\nimport { clamp, toDegrees, toRadian, mat4fromRotationSinCos, rotateNormalBinormal } from './utils.js';\n\nconst tempVec3 = /* @__PURE__ */ new Vec3();\nconst tempMat4 = /* @__PURE__ */ new Mat4();\n\nfunction throwIfNullProperty(property, message) {\n    if (this[property] == null) throw new Error(message);\n}\n\nexport class Path {\n    constructor() {\n        this._segments = [];\n        this._lengthOffsets = null;\n        this._totalLength = -1;\n        this._lastPoint = null;\n        this._lastTilt = 0;\n\n        this._assertLastPoint = throwIfNullProperty.bind(this, '_lastPoint', 'Can`t get previous point of curve. Did you forget moveTo command?');\n\n        this.tiltFunction = null;\n    }\n\n    moveTo(p, tilt = 0) {\n        this._totalLength = -1;\n        this._lastPoint = p;\n        this._lastTilt = tilt;\n    }\n\n    bezierCurveTo(cp1, cp2, p, tilt = 0) {\n        this._assertLastPoint();\n        const seg = new CubicBezierSegment(this._lastPoint, cp1, cp2, p, this._lastTilt, tilt);\n        this.addSegment(seg);\n        return this;\n    }\n\n    quadraticCurveTo(cp, p, tilt = 0) {\n        this._assertLastPoint();\n        const seg = new QuadraticBezierSegment(this._lastPoint, cp, p, this._lastTilt, tilt);\n        this.addSegment(seg);\n        return this;\n    }\n\n    lineTo(p, tilt = 0) {\n        this._assertLastPoint();\n        const seg = new LineSegment(this._lastPoint, p, this._lastTilt, tilt);\n        this.addSegment(seg);\n        return this;\n    }\n\n    addSegment(segment) {\n        this._totalLength = -1;\n        this._lastPoint = segment.lastPoint();\n        this._lastTilt = segment.tiltEnd;\n        this._segments.push(segment);\n        return this;\n    }\n\n    getSegments() {\n        return this._segments;\n    }\n\n    updateLength() {\n        const n = this._segments.length;\n        this._lengthOffsets = new Array(n);\n\n        let offset = 0;\n        for (let i = 0; i < n; i++) {\n            this._lengthOffsets[i] = offset;\n            offset += this._segments[i].getLength();\n        }\n\n        this._totalLength = offset;\n    }\n\n    getLength() {\n        if (this._totalLength < 0) {\n            this.updateLength();\n        }\n\n        return this._totalLength;\n    }\n\n    /**\n     * Finding a path segment at a given absolute length distance\n     * @param {number} len absolute length distance\n     * @returns {[number, number]} [_segment index_, _relative segment distance_]\n     */\n    findSegmentIndexAtLength(len) {\n        const totalLength = this.getLength();\n\n        if (len <= 0) {\n            return [0, 0];\n        }\n\n        if (len >= totalLength) {\n            return [this._segments.length - 1, 1];\n        }\n\n        let start = 0;\n        let end = this._lengthOffsets.length - 1;\n        let index = -1;\n        let mid;\n\n        while (start <= end) {\n            mid = Math.ceil((start + end) / 2);\n\n            if (mid === 0 || mid === this._lengthOffsets.length - 1 || (len >= this._lengthOffsets[mid] && len < this._lengthOffsets[mid + 1])) {\n                index = mid;\n                break;\n            } else if (len < this._lengthOffsets[mid]) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n\n        const seg = this._segments[index];\n        const segLen = seg.getLength();\n        const t = (len - this._lengthOffsets[index]) / segLen;\n\n        return [index, t];\n    }\n\n    getPointAtLength(len, out = new Vec3()) {\n        const [i, t] = this.findSegmentIndexAtLength(len);\n        return this._segments[i].getPointAt(t, out);\n    }\n\n    getPointAt(t, out = new Vec3()) {\n        const totalLength = this.getLength();\n        return this.getPointAtLength(t * totalLength, out);\n    }\n\n    getTangentAtLength(len, out = new Vec3()) {\n        const [i, t] = this.findSegmentIndexAtLength(len);\n        return this._segments[i].getTangentAt(t, out);\n    }\n\n    getTangentAt(t, out = new Vec3()) {\n        const totalLength = this.getLength();\n        return this.getTangentAtLength(t * totalLength, out);\n    }\n\n    getTiltAtLength(len) {\n        const [i, t] = this.findSegmentIndexAtLength(len);\n        return this._segments[i].getTiltAt(t);\n    }\n\n    getTiltAt(t) {\n        const totalLength = this.getLength();\n        return this.getTiltAtLength(t * totalLength);\n    }\n\n    /**\n     * Get sequence of points using `getPointAt(t)`\n     * @param {number} divisions number of subdivisions\n     * @returns {Vec3[]} array of points\n     */\n    getPoints(divisions = 64) {\n        const points = new Array(divisions + 1);\n        for (let i = 0; i <= divisions; i++) {\n            points[i] = this.getPointAt(i / divisions);\n        }\n        return points;\n    }\n\n    /**\n     * Generates the Frenet Frames.\n     * See http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n     * @param {number} divisions number of subdivisions\n     * @returns {{tangents: Vec3[], normals: Vec3[], binormals: Vec3[]}} Object with tangents, normals and binormals arrays\n     */\n    computeFrenetFrames(divisions = 64, closed = false) {\n        const tangents = new Array(divisions + 1);\n        const tilts = new Array(divisions + 1);\n\n        const tiltFunction = this.tiltFunction ?? ((a) => a);\n\n        // compute the tangent vectors and tilt for each segment on the curve\n        const totalLength = this.getLength();\n        for (let i = 0; i <= divisions; i++) {\n            const [si, st] = this.findSegmentIndexAtLength((totalLength * i) / divisions);\n            const segment = this._segments[si];\n            tangents[i] = segment.getTangentAt(st);\n            tilts[i] = tiltFunction(segment.getTiltAt(st), i / divisions, this);\n        }\n\n        const tx = Math.abs(tangents[0].x);\n        const ty = Math.abs(tangents[0].y);\n        const tz = Math.abs(tangents[0].z);\n\n        const normal = new Vec3();\n        if (tx < ty && tx < tz) {\n            normal.set(1, 0, 0);\n        } else if (ty < tx && ty < tz) {\n            normal.set(0, 1, 0);\n        } else {\n            normal.set(0, 0, 1);\n        }\n\n        // select an initial normal vector perpendicular to the first tangent vector,\n        // and in the direction of the minimum tangent xyz component\n        const normals = new Array(divisions + 1);\n        const binormals = new Array(divisions + 1);\n        normals[0] = new Vec3();\n        binormals[0] = new Vec3();\n\n        tempVec3.cross(tangents[0], normal).normalize();\n        normals[0].cross(tangents[0], tempVec3);\n        binormals[0].cross(tangents[0], normals[0]);\n\n        // compute the slowly-varying normal vector for each segment on the curve\n        for (let i = 1; i < tangents.length; i++) {\n            normals[i] = normals[i - 1].clone();\n            binormals[i] = new Vec3();\n\n            tempVec3.cross(tangents[i - 1], tangents[i]);\n            const crossLen = tempVec3.len();\n\n            if (crossLen > Number.EPSILON) {\n                tempVec3.scale(1 / crossLen); // nomalize\n                const cosTheta = clamp(tangents[i - 1].dot(tangents[i]), -1, 1); // clamp for floating pt errors\n                const sinTheta = clamp(crossLen, -1, 1);\n\n                mat4fromRotationSinCos(tempMat4, tempVec3, sinTheta, cosTheta);\n                normals[i].applyMatrix4(tempMat4);\n            }\n\n            binormals[i].cross(tangents[i], normals[i]);\n        }\n\n        // add tilt twisting\n        for (let i = 0; i < tilts.length; i++) {\n            rotateNormalBinormal(toRadian(tilts[i]), normals[i], binormals[i]);\n        }\n\n        // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n        if (closed === true) {\n            const normalLast = normals[normals.length - 1];\n            let step = Math.acos(clamp(normals[0].dot(normalLast), -1, 1)) / (normals.length - 1);\n\n            if (tangents[0].dot(tempVec3.cross(normals[0], normalLast)) > 0) {\n                step = -step;\n            }\n\n            for (let i = 1; i < normals.length - 1; i++) {\n                const angle = step * i;\n                rotateNormalBinormal(angle, normals[i], binormals[i]);\n                tilts[i] += toDegrees(angle);\n            }\n\n            normals[normals.length - 1] = normals[0].clone();\n            binormals[binormals.length - 1] = binormals[0].clone();\n        }\n\n        return { tangents, normals, binormals, tilts };\n    }\n}\n"],"mappings":"AAAA,SAASA,IAAI,QAAQ,oBAAoB;AACzC,SAASC,IAAI,QAAQ,oBAAoB;AACzC,OAAOC,kBAAkB,MAAM,yBAAyB;AACxD,OAAOC,sBAAsB,MAAM,6BAA6B;AAChE,OAAOC,WAAW,MAAM,kBAAkB;AAC1C,SAASC,KAAK,EAAEC,SAAS,EAAEC,QAAQ,EAAEC,sBAAsB,EAAEC,oBAAoB,QAAQ,YAAY;AAErG,MAAMC,QAAQ,GAAG,eAAgB,IAAIV,IAAI,CAAC,CAAC;AAC3C,MAAMW,QAAQ,GAAG,eAAgB,IAAIV,IAAI,CAAC,CAAC;AAE3C,SAASW,mBAAmBA,CAACC,QAAQ,EAAEC,OAAO,EAAE;EAC5C,IAAI,IAAI,CAACD,QAAQ,CAAC,IAAI,IAAI,EAAE,MAAM,IAAIE,KAAK,CAACD,OAAO,CAAC;AACxD;AAEA,OAAO,MAAME,IAAI,CAAC;EACdC,WAAWA,CAAA,EAAG;IACV,IAAI,CAACC,SAAS,GAAG,EAAE;IACnB,IAAI,CAACC,cAAc,GAAG,IAAI;IAC1B,IAAI,CAACC,YAAY,GAAG,CAAC,CAAC;IACtB,IAAI,CAACC,UAAU,GAAG,IAAI;IACtB,IAAI,CAACC,SAAS,GAAG,CAAC;IAElB,IAAI,CAACC,gBAAgB,GAAGX,mBAAmB,CAACY,IAAI,CAAC,IAAI,EAAE,YAAY,EAAE,mEAAmE,CAAC;IAEzI,IAAI,CAACC,YAAY,GAAG,IAAI;EAC5B;EAEAC,MAAMA,CAACC,CAAC,EAAEC,IAAI,GAAG,CAAC,EAAE;IAChB,IAAI,CAACR,YAAY,GAAG,CAAC,CAAC;IACtB,IAAI,CAACC,UAAU,GAAGM,CAAC;IACnB,IAAI,CAACL,SAAS,GAAGM,IAAI;EACzB;EAEAC,aAAaA,CAACC,GAAG,EAAEC,GAAG,EAAEJ,CAAC,EAAEC,IAAI,GAAG,CAAC,EAAE;IACjC,IAAI,CAACL,gBAAgB,CAAC,CAAC;IACvB,MAAMS,GAAG,GAAG,IAAI9B,kBAAkB,CAAC,IAAI,CAACmB,UAAU,EAAES,GAAG,EAAEC,GAAG,EAAEJ,CAAC,EAAE,IAAI,CAACL,SAAS,EAAEM,IAAI,CAAC;IACtF,IAAI,CAACK,UAAU,CAACD,GAAG,CAAC;IACpB,OAAO,IAAI;EACf;EAEAE,gBAAgBA,CAACC,EAAE,EAAER,CAAC,EAAEC,IAAI,GAAG,CAAC,EAAE;IAC9B,IAAI,CAACL,gBAAgB,CAAC,CAAC;IACvB,MAAMS,GAAG,GAAG,IAAI7B,sBAAsB,CAAC,IAAI,CAACkB,UAAU,EAAEc,EAAE,EAAER,CAAC,EAAE,IAAI,CAACL,SAAS,EAAEM,IAAI,CAAC;IACpF,IAAI,CAACK,UAAU,CAACD,GAAG,CAAC;IACpB,OAAO,IAAI;EACf;EAEAI,MAAMA,CAACT,CAAC,EAAEC,IAAI,GAAG,CAAC,EAAE;IAChB,IAAI,CAACL,gBAAgB,CAAC,CAAC;IACvB,MAAMS,GAAG,GAAG,IAAI5B,WAAW,CAAC,IAAI,CAACiB,UAAU,EAAEM,CAAC,EAAE,IAAI,CAACL,SAAS,EAAEM,IAAI,CAAC;IACrE,IAAI,CAACK,UAAU,CAACD,GAAG,CAAC;IACpB,OAAO,IAAI;EACf;EAEAC,UAAUA,CAACI,OAAO,EAAE;IAChB,IAAI,CAACjB,YAAY,GAAG,CAAC,CAAC;IACtB,IAAI,CAACC,UAAU,GAAGgB,OAAO,CAACC,SAAS,CAAC,CAAC;IACrC,IAAI,CAAChB,SAAS,GAAGe,OAAO,CAACE,OAAO;IAChC,IAAI,CAACrB,SAAS,CAACsB,IAAI,CAACH,OAAO,CAAC;IAC5B,OAAO,IAAI;EACf;EAEAI,WAAWA,CAAA,EAAG;IACV,OAAO,IAAI,CAACvB,SAAS;EACzB;EAEAwB,YAAYA,CAAA,EAAG;IACX,MAAMC,CAAC,GAAG,IAAI,CAACzB,SAAS,CAAC0B,MAAM;IAC/B,IAAI,CAACzB,cAAc,GAAG,IAAI0B,KAAK,CAACF,CAAC,CAAC;IAElC,IAAIG,MAAM,GAAG,CAAC;IACd,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,CAAC,EAAEI,CAAC,EAAE,EAAE;MACxB,IAAI,CAAC5B,cAAc,CAAC4B,CAAC,CAAC,GAAGD,MAAM;MAC/BA,MAAM,IAAI,IAAI,CAAC5B,SAAS,CAAC6B,CAAC,CAAC,CAACC,SAAS,CAAC,CAAC;IAC3C;IAEA,IAAI,CAAC5B,YAAY,GAAG0B,MAAM;EAC9B;EAEAE,SAASA,CAAA,EAAG;IACR,IAAI,IAAI,CAAC5B,YAAY,GAAG,CAAC,EAAE;MACvB,IAAI,CAACsB,YAAY,CAAC,CAAC;IACvB;IAEA,OAAO,IAAI,CAACtB,YAAY;EAC5B;;EAEA;AACJ;AACA;AACA;AACA;EACI6B,wBAAwBA,CAACC,GAAG,EAAE;IAC1B,MAAMC,WAAW,GAAG,IAAI,CAACH,SAAS,CAAC,CAAC;IAEpC,IAAIE,GAAG,IAAI,CAAC,EAAE;MACV,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC;IACjB;IAEA,IAAIA,GAAG,IAAIC,WAAW,EAAE;MACpB,OAAO,CAAC,IAAI,CAACjC,SAAS,CAAC0B,MAAM,GAAG,CAAC,EAAE,CAAC,CAAC;IACzC;IAEA,IAAIQ,KAAK,GAAG,CAAC;IACb,IAAIC,GAAG,GAAG,IAAI,CAAClC,cAAc,CAACyB,MAAM,GAAG,CAAC;IACxC,IAAIU,KAAK,GAAG,CAAC,CAAC;IACd,IAAIC,GAAG;IAEP,OAAOH,KAAK,IAAIC,GAAG,EAAE;MACjBE,GAAG,GAAGC,IAAI,CAACC,IAAI,CAAC,CAACL,KAAK,GAAGC,GAAG,IAAI,CAAC,CAAC;MAElC,IAAIE,GAAG,KAAK,CAAC,IAAIA,GAAG,KAAK,IAAI,CAACpC,cAAc,CAACyB,MAAM,GAAG,CAAC,IAAKM,GAAG,IAAI,IAAI,CAAC/B,cAAc,CAACoC,GAAG,CAAC,IAAIL,GAAG,GAAG,IAAI,CAAC/B,cAAc,CAACoC,GAAG,GAAG,CAAC,CAAE,EAAE;QAChID,KAAK,GAAGC,GAAG;QACX;MACJ,CAAC,MAAM,IAAIL,GAAG,GAAG,IAAI,CAAC/B,cAAc,CAACoC,GAAG,CAAC,EAAE;QACvCF,GAAG,GAAGE,GAAG,GAAG,CAAC;MACjB,CAAC,MAAM;QACHH,KAAK,GAAGG,GAAG,GAAG,CAAC;MACnB;IACJ;IAEA,MAAMvB,GAAG,GAAG,IAAI,CAACd,SAAS,CAACoC,KAAK,CAAC;IACjC,MAAMI,MAAM,GAAG1B,GAAG,CAACgB,SAAS,CAAC,CAAC;IAC9B,MAAMW,CAAC,GAAG,CAACT,GAAG,GAAG,IAAI,CAAC/B,cAAc,CAACmC,KAAK,CAAC,IAAII,MAAM;IAErD,OAAO,CAACJ,KAAK,EAAEK,CAAC,CAAC;EACrB;EAEAC,gBAAgBA,CAACV,GAAG,EAAEW,GAAG,GAAG,IAAI7D,IAAI,CAAC,CAAC,EAAE;IACpC,MAAM,CAAC+C,CAAC,EAAEY,CAAC,CAAC,GAAG,IAAI,CAACV,wBAAwB,CAACC,GAAG,CAAC;IACjD,OAAO,IAAI,CAAChC,SAAS,CAAC6B,CAAC,CAAC,CAACe,UAAU,CAACH,CAAC,EAAEE,GAAG,CAAC;EAC/C;EAEAC,UAAUA,CAACH,CAAC,EAAEE,GAAG,GAAG,IAAI7D,IAAI,CAAC,CAAC,EAAE;IAC5B,MAAMmD,WAAW,GAAG,IAAI,CAACH,SAAS,CAAC,CAAC;IACpC,OAAO,IAAI,CAACY,gBAAgB,CAACD,CAAC,GAAGR,WAAW,EAAEU,GAAG,CAAC;EACtD;EAEAE,kBAAkBA,CAACb,GAAG,EAAEW,GAAG,GAAG,IAAI7D,IAAI,CAAC,CAAC,EAAE;IACtC,MAAM,CAAC+C,CAAC,EAAEY,CAAC,CAAC,GAAG,IAAI,CAACV,wBAAwB,CAACC,GAAG,CAAC;IACjD,OAAO,IAAI,CAAChC,SAAS,CAAC6B,CAAC,CAAC,CAACiB,YAAY,CAACL,CAAC,EAAEE,GAAG,CAAC;EACjD;EAEAG,YAAYA,CAACL,CAAC,EAAEE,GAAG,GAAG,IAAI7D,IAAI,CAAC,CAAC,EAAE;IAC9B,MAAMmD,WAAW,GAAG,IAAI,CAACH,SAAS,CAAC,CAAC;IACpC,OAAO,IAAI,CAACe,kBAAkB,CAACJ,CAAC,GAAGR,WAAW,EAAEU,GAAG,CAAC;EACxD;EAEAI,eAAeA,CAACf,GAAG,EAAE;IACjB,MAAM,CAACH,CAAC,EAAEY,CAAC,CAAC,GAAG,IAAI,CAACV,wBAAwB,CAACC,GAAG,CAAC;IACjD,OAAO,IAAI,CAAChC,SAAS,CAAC6B,CAAC,CAAC,CAACmB,SAAS,CAACP,CAAC,CAAC;EACzC;EAEAO,SAASA,CAACP,CAAC,EAAE;IACT,MAAMR,WAAW,GAAG,IAAI,CAACH,SAAS,CAAC,CAAC;IACpC,OAAO,IAAI,CAACiB,eAAe,CAACN,CAAC,GAAGR,WAAW,CAAC;EAChD;;EAEA;AACJ;AACA;AACA;AACA;EACIgB,SAASA,CAACC,SAAS,GAAG,EAAE,EAAE;IACtB,MAAMC,MAAM,GAAG,IAAIxB,KAAK,CAACuB,SAAS,GAAG,CAAC,CAAC;IACvC,KAAK,IAAIrB,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIqB,SAAS,EAAErB,CAAC,EAAE,EAAE;MACjCsB,MAAM,CAACtB,CAAC,CAAC,GAAG,IAAI,CAACe,UAAU,CAACf,CAAC,GAAGqB,SAAS,CAAC;IAC9C;IACA,OAAOC,MAAM;EACjB;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACIC,mBAAmBA,CAACF,SAAS,GAAG,EAAE,EAAEG,MAAM,GAAG,KAAK,EAAE;IAChD,MAAMC,QAAQ,GAAG,IAAI3B,KAAK,CAACuB,SAAS,GAAG,CAAC,CAAC;IACzC,MAAMK,KAAK,GAAG,IAAI5B,KAAK,CAACuB,SAAS,GAAG,CAAC,CAAC;IAEtC,MAAM3C,YAAY,GAAG,IAAI,CAACA,YAAY,KAAMiD,CAAC,IAAKA,CAAC,CAAC;;IAEpD;IACA,MAAMvB,WAAW,GAAG,IAAI,CAACH,SAAS,CAAC,CAAC;IACpC,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIqB,SAAS,EAAErB,CAAC,EAAE,EAAE;MACjC,MAAM,CAAC4B,EAAE,EAAEC,EAAE,CAAC,GAAG,IAAI,CAAC3B,wBAAwB,CAAEE,WAAW,GAAGJ,CAAC,GAAIqB,SAAS,CAAC;MAC7E,MAAM/B,OAAO,GAAG,IAAI,CAACnB,SAAS,CAACyD,EAAE,CAAC;MAClCH,QAAQ,CAACzB,CAAC,CAAC,GAAGV,OAAO,CAAC2B,YAAY,CAACY,EAAE,CAAC;MACtCH,KAAK,CAAC1B,CAAC,CAAC,GAAGtB,YAAY,CAACY,OAAO,CAAC6B,SAAS,CAACU,EAAE,CAAC,EAAE7B,CAAC,GAAGqB,SAAS,EAAE,IAAI,CAAC;IACvE;IAEA,MAAMS,EAAE,GAAGrB,IAAI,CAACsB,GAAG,CAACN,QAAQ,CAAC,CAAC,CAAC,CAACO,CAAC,CAAC;IAClC,MAAMC,EAAE,GAAGxB,IAAI,CAACsB,GAAG,CAACN,QAAQ,CAAC,CAAC,CAAC,CAACS,CAAC,CAAC;IAClC,MAAMC,EAAE,GAAG1B,IAAI,CAACsB,GAAG,CAACN,QAAQ,CAAC,CAAC,CAAC,CAACW,CAAC,CAAC;IAElC,MAAMC,MAAM,GAAG,IAAIpF,IAAI,CAAC,CAAC;IACzB,IAAI6E,EAAE,GAAGG,EAAE,IAAIH,EAAE,GAAGK,EAAE,EAAE;MACpBE,MAAM,CAACC,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACvB,CAAC,MAAM,IAAIL,EAAE,GAAGH,EAAE,IAAIG,EAAE,GAAGE,EAAE,EAAE;MAC3BE,MAAM,CAACC,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACvB,CAAC,MAAM;MACHD,MAAM,CAACC,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACvB;;IAEA;IACA;IACA,MAAMC,OAAO,GAAG,IAAIzC,KAAK,CAACuB,SAAS,GAAG,CAAC,CAAC;IACxC,MAAMmB,SAAS,GAAG,IAAI1C,KAAK,CAACuB,SAAS,GAAG,CAAC,CAAC;IAC1CkB,OAAO,CAAC,CAAC,CAAC,GAAG,IAAItF,IAAI,CAAC,CAAC;IACvBuF,SAAS,CAAC,CAAC,CAAC,GAAG,IAAIvF,IAAI,CAAC,CAAC;IAEzBU,QAAQ,CAAC8E,KAAK,CAAChB,QAAQ,CAAC,CAAC,CAAC,EAAEY,MAAM,CAAC,CAACK,SAAS,CAAC,CAAC;IAC/CH,OAAO,CAAC,CAAC,CAAC,CAACE,KAAK,CAAChB,QAAQ,CAAC,CAAC,CAAC,EAAE9D,QAAQ,CAAC;IACvC6E,SAAS,CAAC,CAAC,CAAC,CAACC,KAAK,CAAChB,QAAQ,CAAC,CAAC,CAAC,EAAEc,OAAO,CAAC,CAAC,CAAC,CAAC;;IAE3C;IACA,KAAK,IAAIvC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyB,QAAQ,CAAC5B,MAAM,EAAEG,CAAC,EAAE,EAAE;MACtCuC,OAAO,CAACvC,CAAC,CAAC,GAAGuC,OAAO,CAACvC,CAAC,GAAG,CAAC,CAAC,CAAC2C,KAAK,CAAC,CAAC;MACnCH,SAAS,CAACxC,CAAC,CAAC,GAAG,IAAI/C,IAAI,CAAC,CAAC;MAEzBU,QAAQ,CAAC8E,KAAK,CAAChB,QAAQ,CAACzB,CAAC,GAAG,CAAC,CAAC,EAAEyB,QAAQ,CAACzB,CAAC,CAAC,CAAC;MAC5C,MAAM4C,QAAQ,GAAGjF,QAAQ,CAACwC,GAAG,CAAC,CAAC;MAE/B,IAAIyC,QAAQ,GAAGC,MAAM,CAACC,OAAO,EAAE;QAC3BnF,QAAQ,CAACoF,KAAK,CAAC,CAAC,GAAGH,QAAQ,CAAC,CAAC,CAAC;QAC9B,MAAMI,QAAQ,GAAG1F,KAAK,CAACmE,QAAQ,CAACzB,CAAC,GAAG,CAAC,CAAC,CAACiD,GAAG,CAACxB,QAAQ,CAACzB,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QACjE,MAAMkD,QAAQ,GAAG5F,KAAK,CAACsF,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;QAEvCnF,sBAAsB,CAACG,QAAQ,EAAED,QAAQ,EAAEuF,QAAQ,EAAEF,QAAQ,CAAC;QAC9DT,OAAO,CAACvC,CAAC,CAAC,CAACmD,YAAY,CAACvF,QAAQ,CAAC;MACrC;MAEA4E,SAAS,CAACxC,CAAC,CAAC,CAACyC,KAAK,CAAChB,QAAQ,CAACzB,CAAC,CAAC,EAAEuC,OAAO,CAACvC,CAAC,CAAC,CAAC;IAC/C;;IAEA;IACA,KAAK,IAAIA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0B,KAAK,CAAC7B,MAAM,EAAEG,CAAC,EAAE,EAAE;MACnCtC,oBAAoB,CAACF,QAAQ,CAACkE,KAAK,CAAC1B,CAAC,CAAC,CAAC,EAAEuC,OAAO,CAACvC,CAAC,CAAC,EAAEwC,SAAS,CAACxC,CAAC,CAAC,CAAC;IACtE;;IAEA;IACA,IAAIwB,MAAM,KAAK,IAAI,EAAE;MACjB,MAAM4B,UAAU,GAAGb,OAAO,CAACA,OAAO,CAAC1C,MAAM,GAAG,CAAC,CAAC;MAC9C,IAAIwD,IAAI,GAAG5C,IAAI,CAAC6C,IAAI,CAAChG,KAAK,CAACiF,OAAO,CAAC,CAAC,CAAC,CAACU,GAAG,CAACG,UAAU,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAIb,OAAO,CAAC1C,MAAM,GAAG,CAAC,CAAC;MAErF,IAAI4B,QAAQ,CAAC,CAAC,CAAC,CAACwB,GAAG,CAACtF,QAAQ,CAAC8E,KAAK,CAACF,OAAO,CAAC,CAAC,CAAC,EAAEa,UAAU,CAAC,CAAC,GAAG,CAAC,EAAE;QAC7DC,IAAI,GAAG,CAACA,IAAI;MAChB;MAEA,KAAK,IAAIrD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuC,OAAO,CAAC1C,MAAM,GAAG,CAAC,EAAEG,CAAC,EAAE,EAAE;QACzC,MAAMuD,KAAK,GAAGF,IAAI,GAAGrD,CAAC;QACtBtC,oBAAoB,CAAC6F,KAAK,EAAEhB,OAAO,CAACvC,CAAC,CAAC,EAAEwC,SAAS,CAACxC,CAAC,CAAC,CAAC;QACrD0B,KAAK,CAAC1B,CAAC,CAAC,IAAIzC,SAAS,CAACgG,KAAK,CAAC;MAChC;MAEAhB,OAAO,CAACA,OAAO,CAAC1C,MAAM,GAAG,CAAC,CAAC,GAAG0C,OAAO,CAAC,CAAC,CAAC,CAACI,KAAK,CAAC,CAAC;MAChDH,SAAS,CAACA,SAAS,CAAC3C,MAAM,GAAG,CAAC,CAAC,GAAG2C,SAAS,CAAC,CAAC,CAAC,CAACG,KAAK,CAAC,CAAC;IAC1D;IAEA,OAAO;MAAElB,QAAQ;MAAEc,OAAO;MAAEC,SAAS;MAAEd;IAAM,CAAC;EAClD;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}